---
layout: default
title: malware_pipeline_phase_1
---

# <u> Malware Pipeline Phase 1 </u>

## 1. Defining the Threat Model

This program assumes all input files are untrusted and potentially malicious

### Assumptions
- Input files may attempt to execute, evade detection, or consume excessive resources
- Filenames, extensions, and metadata cannot be trusted
- Identical malware samples may be submitted multiple times

### Primary Threats
- Accidental execution during ingestion
- File tampering or replacement after submission
- Resource exhaustion through large or malformed files
- File-type masquerading (e.g., renamed executables)

### Trust Boundaries
- External input directory → ingestion process
- Ingestion process → quarantine storage

### Design Implications
- Files are hashed before storage to ensure integrity and enable deduplication
- Files are read in fixed-size chunks to prevent memory exhaustion
- File type detection is based on magic bytes rather than extensions
- Quarantined files are stored with execution disabled and isolated from analysis logic

The threat model informed all ingestion and quarantine decisions to ensure untrusted input could not impact system integrity or analyst safety.

## 2. Creating Ingestion Workflow diagram

![Ingestion Workflow](malware_pipeline_assets/image.png)

### Input directory

- The purpose of the input directory is to act as a boundary where untrusted files can enter the pipeline in a controlled way
- This makes it easier to contain because all files that are in that directory are treated as malicious by default
- Files are read-only and under no circumstances are executed. The directory contents are iterated over without executing anything

### Cryptographic Hashing using SHA-256

- This is used a unique file indetifier for each file in the pipeline and is later used in deduplication to prevent unecessary file processing and computer resources being used
- The unique identifier ensures file integrity (file tampering can be recognised) and enables chain-of-custody tracking
- Files in the input directory are read in fixed-size chunks and hashed using the haslib library

### File type detection


